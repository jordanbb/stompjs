{"version":3,"sources":["webpack://StompJs/webpack/universalModuleDefinition","webpack://StompJs/webpack/bootstrap","webpack://StompJs/./src/versions.ts","webpack://StompJs/./src/web-socket-state.ts","webpack://StompJs/./src/client.ts","webpack://StompJs/./src/byte.ts","webpack://StompJs/./src/frame-impl.ts","webpack://StompJs/./src/parser.ts","webpack://StompJs/./src/compatibility/compat-client.ts","webpack://StompJs/./src/index.ts","webpack://StompJs/./src/stomp-handler.ts","webpack://StompJs/./src/stomp-config.ts","webpack://StompJs/./src/stomp-headers.ts","webpack://StompJs/./src/stomp-subscription.ts","webpack://StompJs/./src/compatibility/heartbeat-info.ts","webpack://StompJs/./src/compatibility/stomp.ts"],"names":["root","factory","exports","module","define","amd","self","this","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","Versions","versions","supportedVersions","join","protocolVersions","map","x","replace","V1_0","V1_1","V1_2","default","WebSocketState","stomp_handler_1","versions_1","web_socket_state_1","Client","conf","stompVersions","reconnectDelay","heartbeatIncoming","heartbeatOutgoing","useLegacyHeartbeatLogic","splitLargeFrames","maxWebSocketChunkSize","forceBinaryWSFrames","appendMissingNULLonIncoming","_active","noOp","debug","beforeConnect","onConnect","onDisconnect","onUnhandledMessage","onUnhandledReceipt","onUnhandledFrame","onStompError","onWebSocketClose","onWebSocketError","logRawCommunication","connectHeaders","_disconnectHeaders","configure","_webSocket","_stompHandler","disconnectHeaders","connected","connectedVersion","undefined","assign","activate","_connect","_a","sent","_createWebSocket","StompHandler","frame","_this","_disposeStompHandler","evt","_schedule_reconnect","message","start","webSocket","webSocketFactory","WebSocket","brokerURL","binaryType","_reconnector","setTimeout","deactivate","clearTimeout","forceDisconnect","readyState","CONNECTING","OPEN","close","dispose","publish","params","watchForReceipt","receiptId","callback","subscribe","destination","headers","unsubscribe","id","begin","transactionId","commit","abort","ack","messageId","subscriptionId","nack","BYTE","LF","NULL","byte_1","FrameImpl","command","body","binaryBody","escapeHeaderValues","skipContentLengthHeader","_binaryBody","isBinaryBody","_body","TextDecoder","decode","TextEncoder","encode","fromRawFrame","rawFrame","trim","str","_i","reverse","length","header","indexOf","hdrValueUnEscape","toString","serializeCmdAndHeaders","serialize","cmdAndHeaders","toUnit8Array","buffer","lines","keys","name_1","push","hdrValueEscape","isBodyEmpty","bodyLength","sizeOfUTF8","uint8CmdAndHeaders","nullTerminator","Uint8Array","uint8Frame","set","marshall","Parser","onFrame","onIncomingPing","_encoder","_decoder","_token","_initState","parseChunk","segment","chunk","ArrayBuffer","chunkWithNull","byte","_onByte","_collectFrame","_collectCommand","_reinjectByte","_results","_consumeTokenAsUTF8","_collectHeaders","_consumeByte","_collectHeaderKey","_setupCollectBody","_headerKey","_collectHeaderValue","contentLengthHeader","filter","_bodyBytesRemaining","parseInt","_collectBodyFixedSize","_collectBodyNullTerminated","_retrievedBody","_consumeTokenAsRaw","rawResult","client_1","heartbeat_info_1","CompatClient","_super","maxWebSocketFrameSize","_heartbeatInfo","HeartbeatInfo","reconnect_delay","arguments","console","log","apply","__extends","_parseConnect","closeEventCallback","connectCallback","errorCallback","args","Error","login","passcode","host","connect","out","disconnect","disconnectCallback","send","incoming","outgoing","__export","frame_impl_1","parser_1","_client","config","_serverFrameHandlers","CONNECTED","server","_connected","_connectedVersion","version","_escapeHeaderValues","_setupHeartbeat","MESSAGE","subscription","onReceive","_subscriptions","client","RECEIPT","_receiptWatchers","ERROR","_counter","_partialData","_lastServerActivityTS","Date","now","parser","_ttlO","_ttlI","oldPinger","_pinger","oldPonger","_ponger","_lastTimeSetHeartbeatInterval","Math","max","clearInterval","setInterval","delta","onmessage","rawChunkAsString","data","onclose","closeEvent","url","_cleanUp","onerror","errorEvent","onopen","_transmit","split","v","serverOutgoing","serverIncoming","rawChunk","substring","receipt","error","hdrs","txId","transaction","StompConfig","StompHeaders","StompSubscription","compat_client_1","Stomp","protocols","WebSocketClass","over","ws","wsFn","warn"],"mappings":"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","file":"stomp.umd.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StompJs\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StompJs\"] = factory();\n\telse\n\t\troot[\"StompJs\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","/**\r\n * Supported STOMP versions\r\n *\r\n * Part of `@stomp/stompjs`.\r\n */\r\nexport class Versions {\r\n  /**\r\n   * Indicates protocol version 1.0\r\n   */\r\n  public static V1_0 = '1.0';\r\n  /**\r\n   * Indicates protocol version 1.1\r\n   */\r\n  public static V1_1 = '1.1';\r\n  /**\r\n   * Indicates protocol version 1.2\r\n   */\r\n  public static V1_2 = '1.2';\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public static default = new Versions([Versions.V1_0, Versions.V1_1, Versions.V1_2]);\r\n\r\n  /**\r\n   * Takes an array of string of versions, typical elements '1.0', '1.1', or '1.2'\r\n   *\r\n   * You will an instance if this class if you want to override supported versions to be declared during\r\n   * STOMP handshake.\r\n   */\r\n  constructor(public versions: string[]) {\r\n  }\r\n\r\n  /**\r\n   * Used as part of CONNECT STOMP Frame\r\n   */\r\n  public supportedVersions() {\r\n    return this.versions.join(',');\r\n  }\r\n\r\n  /**\r\n   * Used while creating a WebSocket\r\n   */\r\n  public protocolVersions() {\r\n    return this.versions.map((x) => `v${x.replace('.', '')}.stomp`);\r\n  }\r\n}\r\n","/**\r\n * Possible states for the WebSocket, copied here to avoid dependency on WebSocket class\r\n *\r\n * Part of `@stomp/rx-stomp`\r\n *\r\n * @internal\r\n */\r\nexport enum WebSocketState {\r\n  CONNECTING,\r\n  OPEN,\r\n  CLOSING,\r\n  CLOSED\r\n}\r\n","import {ITransaction} from './i-transaction';\r\nimport {StompConfig} from './stomp-config';\r\nimport {StompHandler} from './stomp-handler';\r\nimport {StompHeaders} from './stomp-headers';\r\nimport {StompSubscription} from './stomp-subscription';\r\nimport {\r\n  closeEventCallbackType,\r\n  debugFnType,\r\n  frameCallbackType,\r\n  IPublishParams,\r\n  messageCallbackType,\r\n  wsErrorCallbackType\r\n} from './types';\r\nimport {Versions} from './versions';\r\nimport {WebSocketState} from './web-socket-state';\r\n\r\n/**\r\n * STOMP Client Class.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n */\r\nexport class Client {\r\n  /**\r\n   * The URL for the STOMP broker to connect to.\r\n   * Typically like `\"ws://broker.329broker.com:15674/ws\"` or `\"wss://broker.329broker.com:15674/ws\"`.\r\n   *\r\n   * Only one of this or [Client#webSocketFactory]{@link Client#webSocketFactory} need to be set.\r\n   * If both are set, [Client#webSocketFactory]{@link Client#webSocketFactory} will be used.\r\n   */\r\n  public brokerURL: string;\r\n\r\n  /**\r\n   * STOMP versions to attempt during STOMP handshake. By default versions `1.0`, `1.1`, and `1.2` are attempted.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   *        // Try only versions 1.0 and 1.1\r\n   *        client.stompVersions = new Versions(['1.0', '1.1'])\r\n   * ```\r\n   */\r\n  public stompVersions = Versions.default;\r\n\r\n  /**\r\n   * This function should return a WebSocket or a similar (e.g. SockJS) object.\r\n   * If your STOMP Broker supports WebSockets, prefer setting [Client#brokerURL]{@link Client#brokerURL}.\r\n   *\r\n   * If both this and [Client#brokerURL]{@link Client#brokerURL} are set, this will be used.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   *        // use a WebSocket\r\n   *        client.webSocketFactory= function () {\r\n   *          return new WebSocket(\"wss://broker.329broker.com:15674/ws\");\r\n   *        };\r\n   *\r\n   *        // Typical usage with SockJS\r\n   *        client.webSocketFactory= function () {\r\n   *          return new SockJS(\"http://broker.329broker.com/stomp\");\r\n   *        };\r\n   * ```\r\n   */\r\n  public webSocketFactory: () => WebSocket;\r\n\r\n  /**\r\n   *  automatically reconnect with delay in milliseconds, set to 0 to disable.\r\n   */\r\n  public reconnectDelay: number = 5000;\r\n\r\n  /**\r\n   * Incoming heartbeat interval in milliseconds. Set to 0 to disable.\r\n   */\r\n  public heartbeatIncoming: number = 10000;\r\n\r\n  /**\r\n   * Outgoing heartbeat interval in milliseconds. Set to 0 to disable.\r\n   */\r\n  public heartbeatOutgoing: number = 10000;\r\n\r\n  public useLegacyHeartbeatLogic: boolean = false;\r\n\r\n  /**\r\n   * This switches on a non standard behavior while sending WebSocket packets.\r\n   * It splits larger (text) packets into chunks of [maxWebSocketChunkSize]{@link Client#maxWebSocketChunkSize}.\r\n   * Only Java Spring brokers seems to use this mode.\r\n   *\r\n   * WebSockets, by itself, split large (text) packets,\r\n   * so it is not needed with a truly compliant STOMP/WebSocket broker.\r\n   * Actually setting it for such broker will cause large messages to fail.\r\n   *\r\n   * `false` by default.\r\n   *\r\n   * Binary frames are never split.\r\n   */\r\n  public splitLargeFrames: boolean = false;\r\n\r\n  /**\r\n   * See [splitLargeFrames]{@link Client#splitLargeFrames}.\r\n   * This has no effect if [splitLargeFrames]{@link Client#splitLargeFrames} is `false`.\r\n   */\r\n  public maxWebSocketChunkSize: number = 8 * 1024;\r\n\r\n  /**\r\n   * Usually the\r\n   * [type of WebSocket frame]{@link https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send#Parameters}\r\n   * is automatically decided by type of the payload.\r\n   * Default is `false`, which should work with all compliant brokers.\r\n   *\r\n   * Set this flag to force binary frames.\r\n   */\r\n  public forceBinaryWSFrames: boolean = false;\r\n\r\n  /**\r\n   * A bug in ReactNative chops a string on occurrence of a NULL.\r\n   * See issue [https://github.com/stomp-js/stompjs/issues/89]{@link https://github.com/stomp-js/stompjs/issues/89}.\r\n   * This makes incoming WebSocket messages invalid STOMP packets.\r\n   * Setting this flag attempts to reverse the damage by appending a NULL.\r\n   * If the broker splits a large message into multiple WebSocket messages,\r\n   * this flag will cause data loss and abnormal termination of connection.\r\n   *\r\n   * This is not an ideal solution, but a stop gap until the underlying issue is fixed at ReactNative library.\r\n   */\r\n  public appendMissingNULLonIncoming: boolean = false;\r\n\r\n  /**\r\n   * Underlying WebSocket instance, READONLY.\r\n   */\r\n  get webSocket(): WebSocket {\r\n    return this._webSocket;\r\n  }\r\n  /**\r\n   * Underlying WebSocket instance\r\n   * @internal\r\n   */\r\n  protected _webSocket: WebSocket;\r\n\r\n  /**\r\n   * Connection headers, important keys - `login`, `passcode`, `host`.\r\n   * Though STOMP 1.2 standard marks these keys to be present, check your broker documentation for\r\n   * details specific to your broker.\r\n   */\r\n  public connectHeaders: StompHeaders;\r\n\r\n  /**\r\n   * Disconnection headers.\r\n   */\r\n  get disconnectHeaders(): StompHeaders {\r\n    return this._disconnectHeaders;\r\n  }\r\n\r\n  set disconnectHeaders(value: StompHeaders) {\r\n    this._disconnectHeaders = value;\r\n    if (this._stompHandler) {\r\n      this._stompHandler.disconnectHeaders = this._disconnectHeaders;\r\n    }\r\n  }\r\n  private _disconnectHeaders: StompHeaders;\r\n\r\n  /**\r\n   * This function will be called for any unhandled messages.\r\n   * It is useful for receiving messages sent to RabbitMQ temporary queues.\r\n   *\r\n   * It can also get invoked with stray messages while the server is processing\r\n   * a request to [Client#unsubscribe]{@link Client#unsubscribe}\r\n   * from an endpoint.\r\n   *\r\n   * The actual {@link IMessage} will be passed as parameter to the callback.\r\n   */\r\n  public onUnhandledMessage: messageCallbackType;\r\n\r\n  /**\r\n   * STOMP brokers can be requested to notify when an operation is actually completed.\r\n   * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}. See\r\n   * [Client#watchForReceipt]{@link Client#watchForReceipt} for examples.\r\n   *\r\n   * The actual {@link FrameImpl} will be passed as parameter to the callback.\r\n   */\r\n  public onUnhandledReceipt: frameCallbackType;\r\n\r\n  /**\r\n   * Will be invoked if {@link FrameImpl} of unknown type is received from the STOMP broker.\r\n   *\r\n   * The actual {@link IFrame} will be passed as parameter to the callback.\r\n   */\r\n  public onUnhandledFrame: frameCallbackType;\r\n\r\n  /**\r\n   * `true` if there is a active connection with STOMP Broker\r\n   */\r\n  get connected(): boolean {\r\n    return (!!this._stompHandler) && this._stompHandler.connected;\r\n  }\r\n\r\n  /**\r\n   * Callback, invoked on before a connection connection to the STOMP broker.\r\n   *\r\n   * You can change options on the client, which will impact the immediate connect.\r\n   * It is valid to call [Client#decativate]{@link Client#deactivate} in this callback.\r\n   *\r\n   * As of version 5.1, this callback can be\r\n   * [async](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)\r\n   * (i.e., it can return a\r\n   * [Promise](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise)).\r\n   * In that case connect will be called only after the Promise is resolved.\r\n   * This can be used to reliably fetch credentials, access token etc. from some other service\r\n   * in an asynchronous way.\r\n   */\r\n  public beforeConnect: () => void|Promise<void>;\r\n\r\n  /**\r\n   * Callback, invoked on every successful connection to the STOMP broker.\r\n   *\r\n   * The actual {@link FrameImpl} will be passed as parameter to the callback.\r\n   * Sometimes clients will like to use headers from this frame.\r\n   */\r\n  public onConnect: frameCallbackType;\r\n\r\n  /**\r\n   * Callback, invoked on every successful disconnection from the STOMP broker. It will not be invoked if\r\n   * the STOMP broker disconnected due to an error.\r\n   *\r\n   * The actual Receipt {@link FrameImpl} acknowledging the DISCONNECT will be passed as parameter to the callback.\r\n   *\r\n   * The way STOMP protocol is designed, the connection may close/terminate without the client\r\n   * receiving the Receipt {@link FrameImpl} acknowledging the DISCONNECT.\r\n   * You might find [Client#onWebSocketClose]{@link Client#onWebSocketClose} more appropriate to watch\r\n   * STOMP broker disconnects.\r\n   */\r\n  public onDisconnect: frameCallbackType;\r\n\r\n  /**\r\n   * Callback, invoked on an ERROR frame received from the STOMP Broker.\r\n   * A compliant STOMP Broker will close the connection after this type of frame.\r\n   * Please check broker specific documentation for exact behavior.\r\n   *\r\n   * The actual {@link IFrame} will be passed as parameter to the callback.\r\n   */\r\n  public onStompError: frameCallbackType;\r\n\r\n  /**\r\n   * Callback, invoked when underlying WebSocket is closed.\r\n   *\r\n   * Actual [CloseEvent]{@link https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent}\r\n   * is passed as parameter to the callback.\r\n   */\r\n  public onWebSocketClose: closeEventCallbackType;\r\n\r\n  /**\r\n   * Callback, invoked when underlying WebSocket raises an error.\r\n   *\r\n   * Actual [Event]{@link https://developer.mozilla.org/en-US/docs/Web/API/Event}\r\n   * is passed as parameter to the callback.\r\n   */\r\n  public onWebSocketError: wsErrorCallbackType;\r\n\r\n  /**\r\n   * Set it to log the actual raw communication with the broker.\r\n   * When unset, it logs headers of the parsed frames.\r\n   *\r\n   * Change in this effects from next broker reconnect.\r\n   *\r\n   * **Caution: this assumes that frames only have valid UTF8 strings.**\r\n   */\r\n  public logRawCommunication: boolean;\r\n\r\n  /**\r\n   * By default, debug messages are discarded. To log to `console` following can be used:\r\n   *\r\n   * ```javascript\r\n   *        client.debug = function(str) {\r\n   *          console.log(str);\r\n   *        };\r\n   * ```\r\n   *\r\n   * Currently this method does not support levels of log. Be aware that the output can be quite verbose\r\n   * and may contain sensitive information (like passwords, tokens etc.).\r\n   */\r\n  public debug: debugFnType;\r\n\r\n  /**\r\n   * version of STOMP protocol negotiated with the server, READONLY\r\n   */\r\n  get connectedVersion(): string {\r\n    return this._stompHandler ? this._stompHandler.connectedVersion : undefined;\r\n  }\r\n\r\n  private _stompHandler: StompHandler;\r\n\r\n  /**\r\n   * if the client is active (connected or going to reconnect)\r\n   */\r\n  get active(): boolean {\r\n    return this._active;\r\n  }\r\n  private _active: boolean = false;\r\n  private _reconnector: any;\r\n\r\n  /**\r\n   * Create an instance.\r\n   */\r\n  constructor(conf: StompConfig = {}) {\r\n    // Dummy callbacks\r\n    const noOp = () => {};\r\n    this.debug = noOp;\r\n    this.beforeConnect = noOp;\r\n    this.onConnect = noOp;\r\n    this.onDisconnect = noOp;\r\n    this.onUnhandledMessage = noOp;\r\n    this.onUnhandledReceipt = noOp;\r\n    this.onUnhandledFrame = noOp;\r\n    this.onStompError = noOp;\r\n    this.onWebSocketClose = noOp;\r\n    this.onWebSocketError = noOp;\r\n    this.logRawCommunication = false;\r\n\r\n    // These parameters would typically get proper values before connect is called\r\n    this.connectHeaders = {};\r\n    this._disconnectHeaders = {};\r\n\r\n    // Apply configuration\r\n    this.configure(conf);\r\n  }\r\n\r\n  /**\r\n   * Update configuration.\r\n   */\r\n  public configure(conf: StompConfig): void {\r\n    // bulk assign all properties to this\r\n    (Object as any).assign(this, conf);\r\n  }\r\n\r\n  /**\r\n   * Initiate the connection with the broker.\r\n   * If the connection breaks, as per [Client#reconnectDelay]{@link Client#reconnectDelay},\r\n   * it will keep trying to reconnect.\r\n   *\r\n   * Call [Client#deactivate]{@link Client#deactivate} to disconnect and stop reconnection attempts.\r\n   */\r\n  public activate(): void {\r\n    this._active = true;\r\n\r\n    this._connect();\r\n  }\r\n\r\n  private async _connect(): Promise<void> {\r\n    if (this.connected) {\r\n      this.debug('STOMP: already connected, nothing to do');\r\n      return;\r\n    }\r\n\r\n    await this.beforeConnect();\r\n\r\n    if (!this._active) {\r\n      this.debug('Client has been marked inactive, will not attempt to connect');\r\n      return;\r\n    }\r\n\r\n    this.debug('Opening Web Socket...');\r\n\r\n    // Get the actual WebSocket (or a similar object)\r\n    this._webSocket = this._createWebSocket();\r\n\r\n    this._stompHandler = new StompHandler(this, this._webSocket, {\r\n      debug: this.debug,\r\n      stompVersions: this.stompVersions,\r\n      connectHeaders: this.connectHeaders,\r\n      disconnectHeaders: this._disconnectHeaders,\r\n      heartbeatIncoming: this.heartbeatIncoming,\r\n      heartbeatOutgoing: this.heartbeatOutgoing,\r\n      useLegacyHeartbeatLogic: this.useLegacyHeartbeatLogic,\r\n      splitLargeFrames: this.splitLargeFrames,\r\n      maxWebSocketChunkSize: this.maxWebSocketChunkSize,\r\n      forceBinaryWSFrames: this.forceBinaryWSFrames,\r\n      logRawCommunication: this.logRawCommunication,\r\n      appendMissingNULLonIncoming: this.appendMissingNULLonIncoming,\r\n\r\n      onConnect: (frame) => {\r\n        if (!this._active) {\r\n          this.debug('STOMP got connected while deactivate was issued, will disconnect now');\r\n          this._disposeStompHandler();\r\n          return;\r\n        }\r\n        this.onConnect(frame);\r\n      },\r\n      onDisconnect: (frame) => {\r\n        this.onDisconnect(frame);\r\n      },\r\n      onStompError: (frame) => {\r\n        this.onStompError(frame);\r\n      },\r\n      onWebSocketClose: (evt) => {\r\n        this.onWebSocketClose(evt);\r\n        // The callback is called before attempting to reconnect, this would allow the client\r\n        // to be `deactivated` in the callback.\r\n        if (this._active) {\r\n          this._schedule_reconnect();\r\n        }\r\n      },\r\n      onWebSocketError: (evt) => {\r\n        this.onWebSocketError(evt);\r\n      },\r\n      onUnhandledMessage: (message) => {\r\n        this.onUnhandledMessage(message);\r\n      },\r\n      onUnhandledReceipt: (frame) => {\r\n        this.onUnhandledReceipt(frame);\r\n      },\r\n      onUnhandledFrame: (frame) => {\r\n        this.onUnhandledFrame(frame);\r\n      }\r\n    });\r\n\r\n    this._stompHandler.start();\r\n  }\r\n\r\n  private _createWebSocket() {\r\n    let webSocket: WebSocket;\r\n\r\n    if (this.webSocketFactory) {\r\n      webSocket = this.webSocketFactory();\r\n    } else {\r\n      webSocket = new WebSocket(this.brokerURL, this.stompVersions.protocolVersions());\r\n    }\r\n    webSocket.binaryType = 'arraybuffer';\r\n    return webSocket;\r\n  }\r\n\r\n  private _schedule_reconnect(): void {\r\n    if (this.reconnectDelay > 0) {\r\n      this.debug(`STOMP: scheduling reconnection in ${this.reconnectDelay}ms`);\r\n\r\n      this._reconnector = setTimeout(() => {\r\n        this._connect();\r\n      }, this.reconnectDelay);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Disconnect if connected and stop auto reconnect loop.\r\n   * Appropriate callbacks will be invoked if underlying STOMP connection was connected.\r\n   *\r\n   * To reactivate you can call [Client#activate]{@link Client#activate}.\r\n   */\r\n  public deactivate(): void {\r\n    // indicate that auto reconnect loop should terminate\r\n    this._active = false;\r\n\r\n    // Clear if a reconnection was scheduled\r\n    if (this._reconnector) {\r\n      clearTimeout(this._reconnector);\r\n    }\r\n    this._disposeStompHandler();\r\n  }\r\n\r\n  /**\r\n   * Force disconnect if there is an active connection by directly closing the underlying WebSocket.\r\n   * This is different than a normal disconnect where a DISCONNECT sequence is carried out with the broker.\r\n   * After forcing disconnect, automatic reconnect will be attempted.\r\n   * To stop further reconnects call [Client#deactivate]{@link Client#deactivate} as well.\r\n   */\r\n  public forceDisconnect() {\r\n    if (this._webSocket) {\r\n      if (this._webSocket.readyState === WebSocketState.CONNECTING\r\n              || this._webSocket.readyState === WebSocketState.OPEN) {\r\n        this._webSocket.close();\r\n      }\r\n    }\r\n  }\r\n\r\n  private _disposeStompHandler() {\r\n    // Dispose STOMP Handler\r\n    if (this._stompHandler) {\r\n      this._stompHandler.dispose();\r\n      this._stompHandler = null;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\r\n   * and naming of destinations.\r\n   *\r\n   * STOMP protocol specifies and suggests some headers and also allows broker specific headers.\r\n   *\r\n   * `body` must be String.\r\n   * You will need to covert the payload to string in case it is not string (e.g. JSON).\r\n   *\r\n   * To send a binary message body use binaryBody parameter. It should be a\r\n   * [Uint8Array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Uint8Array).\r\n   * Sometimes brokers may not support binary frames out of the box.\r\n   * Please check your broker documentation.\r\n   *\r\n   * `content-length` header is automatically added to the STOMP Frame sent to the broker.\r\n   * Set `skipContentLengthHeader` to indicate that `content-length` header should not be added.\r\n   * For binary messages `content-length` header is always added.\r\n   *\r\n   * Caution: The broker will, most likely, report an error and disconnect if message body has NULL octet(s)\r\n   * and `content-length` header is missing.\r\n   *\r\n   * ```javascript\r\n   *        client.publish({destination: \"/queue/test\", headers: {priority: 9}, body: \"Hello, STOMP\"});\r\n   *\r\n   *        // Only destination is mandatory parameter\r\n   *        client.publish({destination: \"/queue/test\", body: \"Hello, STOMP\"});\r\n   *\r\n   *        // Skip content-length header in the frame to the broker\r\n   *        client.publish({\"/queue/test\", body: \"Hello, STOMP\", skipContentLengthHeader: true});\r\n   *\r\n   *        var binaryData = generateBinaryData(); // This need to be of type Uint8Array\r\n   *        // setting content-type header is not mandatory, however a good practice\r\n   *        client.publish({destination: '/topic/special', binaryBody: binaryData,\r\n   *                         headers: {'content-type': 'application/octet-stream'}});\r\n   * ```\r\n   */\r\n  public publish(params: IPublishParams) {\r\n    this._stompHandler.publish(params);\r\n  }\r\n\r\n  /**\r\n   * STOMP brokers may carry out operation asynchronously and allow requesting for acknowledgement.\r\n   * To request an acknowledgement, a `receipt` header needs to be sent with the actual request.\r\n   * The value (say receipt-id) for this header needs to be unique for each use. Typically a sequence, a UUID, a\r\n   * random number or a combination may be used.\r\n   *\r\n   * A complaint broker will send a RECEIPT frame when an operation has actually been completed.\r\n   * The operation needs to be matched based in the value of the receipt-id.\r\n   *\r\n   * This method allow watching for a receipt and invoke the callback\r\n   * when corresponding receipt has been received.\r\n   *\r\n   * The actual {@link FrameImpl} will be passed as parameter to the callback.\r\n   *\r\n   * Example:\r\n   * ```javascript\r\n   *        // Subscribing with acknowledgement\r\n   *        let receiptId = randomText();\r\n   *\r\n   *        client.watchForReceipt(receiptId, function() {\r\n   *          // Will be called after server acknowledges\r\n   *        });\r\n   *\r\n   *        client.subscribe(TEST.destination, onMessage, {receipt: receiptId});\r\n   *\r\n   *\r\n   *        // Publishing with acknowledgement\r\n   *        receiptId = randomText();\r\n   *\r\n   *        client.watchForReceipt(receiptId, function() {\r\n   *          // Will be called after server acknowledges\r\n   *        });\r\n   *        client.publish({destination: TEST.destination, headers: {receipt: receiptId}, body: msg});\r\n   * ```\r\n   */\r\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\r\n    this._stompHandler.watchForReceipt(receiptId, callback);\r\n  }\r\n\r\n  /**\r\n   * Subscribe to a STOMP Broker location. The callback will be invoked for each received message with\r\n   * the {@link IMessage} as argument.\r\n   *\r\n   * Note: The library will generate an unique ID if there is none provided in the headers.\r\n   *       To use your own ID, pass it using the headers argument.\r\n   *\r\n   * ```javascript\r\n   *        callback = function(message) {\r\n   *        // called when the client receives a STOMP message from the server\r\n   *          if (message.body) {\r\n   *            alert(\"got message with body \" + message.body)\r\n   *          } else {\r\n   *            alert(\"got empty message\");\r\n   *          }\r\n   *        });\r\n   *\r\n   *        var subscription = client.subscribe(\"/queue/test\", callback);\r\n   *\r\n   *        // Explicit subscription id\r\n   *        var mySubId = 'my-subscription-id-001';\r\n   *        var subscription = client.subscribe(destination, callback, { id: mySubId });\r\n   * ```\r\n   */\r\n  public subscribe(destination: string, callback: messageCallbackType, headers: StompHeaders = {}): StompSubscription {\r\n    return this._stompHandler.subscribe(destination, callback, headers);\r\n  }\r\n\r\n  /**\r\n   * It is preferable to unsubscribe from a subscription by calling\r\n   * `unsubscribe()` directly on {@link StompSubscription} returned by `client.subscribe()`:\r\n   *\r\n   * ```javascript\r\n   *        var subscription = client.subscribe(destination, onmessage);\r\n   *        // ...\r\n   *        subscription.unsubscribe();\r\n   * ```\r\n   *\r\n   * See: http://stomp.github.com/stomp-specification-1.2.html#UNSUBSCRIBE UNSUBSCRIBE Frame\r\n   */\r\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\r\n    this._stompHandler.unsubscribe(id, headers);\r\n  }\r\n\r\n  /**\r\n   * Start a transaction, the returned {@link ITransaction} has methods - [commit]{@link ITransaction#commit}\r\n   * and [abort]{@link ITransaction#abort}.\r\n   *\r\n   * `transactionId` is optional, if not passed the library will generate it internally.\r\n   */\r\n  public begin(transactionId?: string): ITransaction {\r\n    return this._stompHandler.begin(transactionId);\r\n  }\r\n\r\n  /**\r\n   * Commit a transaction.\r\n   *\r\n   * It is preferable to commit a transaction by calling [commit]{@link ITransaction#commit} directly on\r\n   * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\r\n   *\r\n   * ```javascript\r\n   *        var tx = client.begin(txId);\r\n   *        //...\r\n   *        tx.commit();\r\n   * ```\r\n   */\r\n  public commit(transactionId: string): void {\r\n    this._stompHandler.commit(transactionId);\r\n  }\r\n\r\n  /**\r\n   * Abort a transaction.\r\n   * It is preferable to abort a transaction by calling [abort]{@link ITransaction#abort} directly on\r\n   * {@link ITransaction} returned by [client.begin]{@link Client#begin}.\r\n   *\r\n   * ```javascript\r\n   *        var tx = client.begin(txId);\r\n   *        //...\r\n   *        tx.abort();\r\n   * ```\r\n   */\r\n  public abort(transactionId: string): void {\r\n    this._stompHandler.abort(transactionId);\r\n  }\r\n\r\n  /**\r\n   * ACK a message. It is preferable to acknowledge a message by calling [ack]{@link IMessage#ack} directly\r\n   * on the {@link IMessage} handled by a subscription callback:\r\n   *\r\n   * ```javascript\r\n   *        var callback = function (message) {\r\n   *          // process the message\r\n   *          // acknowledge it\r\n   *          message.ack();\r\n   *        };\r\n   *        client.subscribe(destination, callback, {'ack': 'client'});\r\n   * ```\r\n   */\r\n  public ack(messageId: string, subscriptionId: string, headers: StompHeaders = {}): void {\r\n    this._stompHandler.ack(messageId, subscriptionId, headers);\r\n  }\r\n\r\n  /**\r\n   * NACK a message. It is preferable to acknowledge a message by calling [nack]{@link IMessage#nack} directly\r\n   * on the {@link IMessage} handled by a subscription callback:\r\n   *\r\n   * ```javascript\r\n   *        var callback = function (message) {\r\n   *          // process the message\r\n   *          // an error occurs, nack it\r\n   *          message.nack();\r\n   *        };\r\n   *        client.subscribe(destination, callback, {'ack': 'client'});\r\n   * ```\r\n   */\r\n  public nack(messageId: string, subscriptionId: string, headers: StompHeaders = {}): void {\r\n    this._stompHandler.nack(messageId, subscriptionId, headers);\r\n  }\r\n}\r\n","/**\r\n * Some byte values, used as per STOMP specifications.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * @internal\r\n */\r\nexport const BYTE = {\r\n  // LINEFEED byte (octet 10)\r\n  LF: '\\x0A',\r\n  // NULL byte (octet 0)\r\n  NULL: '\\x00'\r\n};\r\n","import {BYTE} from './byte';\r\nimport {IFrame} from './i-frame';\r\nimport {StompHeaders} from './stomp-headers';\r\nimport {IRawFrameType} from './types';\r\n\r\n/**\r\n * Frame class represents a STOMP frame.\r\n *\r\n * @internal\r\n */\r\nexport class FrameImpl implements IFrame {\r\n  /**\r\n   * STOMP Command\r\n   */\r\n  public command: string;\r\n\r\n  /**\r\n   * Headers, key value pairs.\r\n   */\r\n  public headers: StompHeaders;\r\n\r\n  /**\r\n   * Is this frame binary (based on whether body/binaryBody was passed when creating this frame).\r\n   */\r\n  public isBinaryBody: boolean;\r\n\r\n  /**\r\n   * body of the frame\r\n   */\r\n  get body(): string {\r\n    if (!this._body && this.isBinaryBody) {\r\n      this._body = new TextDecoder().decode(this._binaryBody);\r\n    }\r\n    return this._body;\r\n  }\r\n  private _body: string;\r\n\r\n  /**\r\n   * body as Uint8Array\r\n   */\r\n  get binaryBody(): Uint8Array {\r\n    if (!this._binaryBody && !this.isBinaryBody) {\r\n      this._binaryBody = new TextEncoder().encode(this._body);\r\n    }\r\n    return this._binaryBody;\r\n  }\r\n  private _binaryBody: Uint8Array;\r\n\r\n  private escapeHeaderValues: boolean;\r\n  private skipContentLengthHeader: boolean;\r\n\r\n  /**\r\n   * Frame constructor. `command`, `headers` and `body` are available as properties.\r\n   *\r\n   * @internal\r\n   */\r\n  constructor(params: {\r\n    command: string, headers?: StompHeaders, body?: string, binaryBody?: Uint8Array,\r\n    escapeHeaderValues?: boolean, skipContentLengthHeader?: boolean\r\n  }) {\r\n    const {command, headers, body, binaryBody, escapeHeaderValues, skipContentLengthHeader} = params;\r\n    this.command = command;\r\n    this.headers = (Object as any).assign({}, headers || {});\r\n\r\n    if (binaryBody) {\r\n      this._binaryBody = binaryBody;\r\n      this.isBinaryBody = true;\r\n    } else {\r\n      this._body = body || '';\r\n      this.isBinaryBody = false;\r\n    }\r\n    this.escapeHeaderValues = escapeHeaderValues || false;\r\n    this.skipContentLengthHeader = skipContentLengthHeader || false;\r\n  }\r\n\r\n  /**\r\n   * deserialize a STOMP Frame from raw data.\r\n   *\r\n   * @internal\r\n   */\r\n  public static fromRawFrame(rawFrame: IRawFrameType, escapeHeaderValues: boolean): FrameImpl {\r\n    const headers: StompHeaders = {};\r\n    const trim = (str: string): string => str.replace(/^\\s+|\\s+$/g, '');\r\n\r\n    // In case of repeated headers, as per standards, first value need to be used\r\n    for (const header of rawFrame.headers.reverse()) {\r\n      const idx = header.indexOf(':');\r\n\r\n      const key = trim(header[0]);\r\n      let value = trim(header[1]);\r\n\r\n      if (escapeHeaderValues && (rawFrame.command !== 'CONNECT') && (rawFrame.command !== 'CONNECTED')) {\r\n        value = FrameImpl.hdrValueUnEscape(value);\r\n      }\r\n\r\n      headers[key] = value;\r\n    }\r\n\r\n    return new FrameImpl({\r\n      command: rawFrame.command,\r\n      headers,\r\n      binaryBody: rawFrame.binaryBody,\r\n      escapeHeaderValues\r\n    });\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public toString(): string {\r\n    return this.serializeCmdAndHeaders();\r\n  }\r\n\r\n  /**\r\n   * serialize this Frame in a format suitable to be passed to WebSocket.\r\n   * If the body is string the output will be string.\r\n   * If the body is binary (i.e. of type Unit8Array) it will be serialized to ArrayBuffer.\r\n   *\r\n   * @internal\r\n   */\r\n  public serialize(): string|ArrayBuffer {\r\n    const cmdAndHeaders = this.serializeCmdAndHeaders();\r\n\r\n    if (this.isBinaryBody) {\r\n      return FrameImpl.toUnit8Array(cmdAndHeaders, this._binaryBody).buffer;\r\n    } else {\r\n      return cmdAndHeaders + this._body + BYTE.NULL;\r\n    }\r\n  }\r\n\r\n  private serializeCmdAndHeaders(): string {\r\n    const lines = [this.command];\r\n    if (this.skipContentLengthHeader) {\r\n      delete this.headers['content-length'];\r\n    }\r\n\r\n    for (const name of Object.keys(this.headers || {})) {\r\n      const value = this.headers[name];\r\n      if (this.escapeHeaderValues && (this.command !== 'CONNECT') && (this.command !== 'CONNECTED')) {\r\n        lines.push(`${name}:${FrameImpl.hdrValueEscape(`${value}`)}`);\r\n      } else {\r\n        lines.push(`${name}:${value}`);\r\n      }\r\n    }\r\n    if (this.isBinaryBody || (!this.isBodyEmpty() && !this.skipContentLengthHeader)) {\r\n      lines.push(`content-length:${this.bodyLength()}`);\r\n    }\r\n    return lines.join(BYTE.LF) + BYTE.LF + BYTE.LF;\r\n  }\r\n\r\n  private isBodyEmpty(): boolean {\r\n    return this.bodyLength() === 0;\r\n  }\r\n\r\n  private bodyLength(): number {\r\n    const binaryBody = this.binaryBody;\r\n    return binaryBody ? binaryBody.length : 0;\r\n  }\r\n\r\n  /**\r\n   * Compute the size of a UTF-8 string by counting its number of bytes\r\n   * (and not the number of characters composing the string)\r\n   */\r\n  private static sizeOfUTF8(s: string): number {\r\n    return s ? new TextEncoder().encode(s).length : 0;\r\n  }\r\n\r\n  private static toUnit8Array(cmdAndHeaders: string, binaryBody: Uint8Array): Uint8Array {\r\n    const uint8CmdAndHeaders = new TextEncoder().encode(cmdAndHeaders);\r\n    const nullTerminator = new Uint8Array([0]);\r\n    const uint8Frame = new Uint8Array(uint8CmdAndHeaders.length + binaryBody.length + nullTerminator.length);\r\n\r\n    uint8Frame.set(uint8CmdAndHeaders);\r\n    uint8Frame.set(binaryBody, uint8CmdAndHeaders.length);\r\n    uint8Frame.set(nullTerminator, uint8CmdAndHeaders.length + binaryBody.length);\r\n\r\n    return uint8Frame;\r\n  }\r\n  /**\r\n   * Serialize a STOMP frame as per STOMP standards, suitable to be sent to the STOMP broker.\r\n   *\r\n   * @internal\r\n   */\r\n  public static marshall(params: {\r\n    command: string, headers?: StompHeaders, body?: string, binaryBody?: Uint8Array,\r\n    escapeHeaderValues?: boolean, skipContentLengthHeader?: boolean\r\n  }) {\r\n    const frame = new FrameImpl(params);\r\n    return frame.serialize();\r\n  }\r\n\r\n  /**\r\n   *  Escape header values\r\n   */\r\n  private static hdrValueEscape(str: string): string {\r\n    return str.replace(/\\\\/g, '\\\\\\\\').replace(/\\r/g, '\\\\r').replace(/\\n/g, '\\\\n').replace(/:/g, '\\\\c');\r\n  }\r\n\r\n  /**\r\n   * UnEscape header values\r\n   */\r\n  private static hdrValueUnEscape(str: string): string {\r\n    return str.replace(/\\\\r/g, '\\r').replace(/\\\\n/g, '\\n').replace(/\\\\c/g, ':').replace(/\\\\\\\\/g, '\\\\');\r\n  }\r\n}\r\n","import { IRawFrameType } from './types';\r\n\r\n/**\r\n * @internal\r\n */\r\nconst NULL = 0;\r\n/**\r\n * @internal\r\n */\r\nconst LF = 10;\r\n/**\r\n * @internal\r\n */\r\nconst CR = 13;\r\n/**\r\n * @internal\r\n */\r\nconst COLON = 58;\r\n\r\n/**\r\n * This is an evented, rec descent parser.\r\n * A stream of Octets can be passed and whenever it recognizes\r\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\r\n *\r\n * All incoming Octets are fed into _onByte function.\r\n * Depending on current state the _onByte function keeps changing.\r\n * Depending on the state it keeps accumulating into _token and _results.\r\n * State is indicated by current value of _onByte, all states are named as _collect.\r\n *\r\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\r\n * imply that all lengths are considered in bytes (instead of string lengths).\r\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\r\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\r\n *\r\n * There is no peek function on the incoming data.\r\n * When a state change occurs based on an Octet without consuming the Octet,\r\n * the Octet, after state change, is fed again (_reinjectByte).\r\n * This became possible as the state change can be determined by inspecting just one Octet.\r\n *\r\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\r\n * otherwise it is determined by NULL terminator.\r\n *\r\n * Following the standards, the command and headers are converted to Strings\r\n * and the body is returned as Octets.\r\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\r\n *\r\n * This parser does not use Regular Expressions as that can only operate on Strings.\r\n *\r\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\r\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\r\n * is pushed.\r\n *\r\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\r\n * (which is protocol version specific), and convert body to text.\r\n *\r\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * @internal\r\n */\r\nexport class Parser {\r\n  private readonly _encoder = new TextEncoder();\r\n  private readonly _decoder = new TextDecoder();\r\n\r\n  private _results: IRawFrameType;\r\n\r\n  private _token: number[] = [];\r\n  private _headerKey: string;\r\n  private _bodyBytesRemaining: number;\r\n\r\n  private _onByte: (byte: number) => void;\r\n\r\n  public constructor(public onFrame: (rawFrame: IRawFrameType) => void, public onIncomingPing: () => void) {\r\n    this._initState();\r\n  }\r\n\r\n  public parseChunk(segment: string | ArrayBuffer, appendMissingNULLonIncoming: boolean = false) {\r\n    let chunk: Uint8Array;\r\n\r\n    if ((segment instanceof ArrayBuffer)) {\r\n      chunk = new Uint8Array(segment);\r\n    } else {\r\n      chunk = this._encoder.encode(segment);\r\n    }\r\n\r\n    // See https://github.com/stomp-js/stompjs/issues/89\r\n    // Remove when underlying issue is fixed.\r\n    //\r\n    // Send a NULL byte, if the last byte of a Text frame was not NULL.F\r\n    if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\r\n      const chunkWithNull = new Uint8Array(chunk.length + 1);\r\n      chunkWithNull.set(chunk, 0);\r\n      chunkWithNull[chunk.length] = 0;\r\n      chunk = chunkWithNull;\r\n    }\r\n\r\n    // tslint:disable-next-line:prefer-for-of\r\n    for (let i = 0; i < chunk.length; i++) {\r\n      const byte = chunk[i];\r\n      this._onByte(byte);\r\n    }\r\n  }\r\n\r\n  // The following implements a simple Rec Descent Parser.\r\n  // The grammar is simple and just one byte tells what should be the next state\r\n\r\n  private _collectFrame(byte: number): void {\r\n    if (byte === NULL) { // Ignore\r\n      return;\r\n    }\r\n    if (byte === CR) { // Ignore CR\r\n      return;\r\n    }\r\n    if (byte === LF) { // Incoming Ping\r\n      this.onIncomingPing();\r\n      return;\r\n    }\r\n\r\n    this._onByte = this._collectCommand;\r\n    this._reinjectByte(byte);\r\n  }\r\n\r\n  private _collectCommand(byte: number): void {\r\n    if (byte === CR) { // Ignore CR\r\n      return;\r\n    }\r\n    if (byte === LF) {\r\n      this._results.command = this._consumeTokenAsUTF8();\r\n      this._onByte = this._collectHeaders;\r\n      return;\r\n    }\r\n\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _collectHeaders(byte: number): void {\r\n    if (byte === CR) { // Ignore CR\r\n      return;\r\n    }\r\n    if (byte === LF) {\r\n      this._setupCollectBody();\r\n      return;\r\n    }\r\n    this._onByte = this._collectHeaderKey;\r\n    this._reinjectByte(byte);\r\n  }\r\n\r\n  private _reinjectByte(byte: number) {\r\n    this._onByte(byte);\r\n  }\r\n\r\n  private _collectHeaderKey(byte: number): void {\r\n    if (byte === COLON) {\r\n      this._headerKey = this._consumeTokenAsUTF8();\r\n      this._onByte = this._collectHeaderValue;\r\n      return;\r\n    }\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _collectHeaderValue(byte: number): void {\r\n    if (byte === CR) { // Ignore CR\r\n      return;\r\n    }\r\n    if (byte === LF) {\r\n      this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\r\n      this._headerKey = undefined;\r\n      this._onByte = this._collectHeaders;\r\n      return;\r\n    }\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _setupCollectBody() {\r\n    const contentLengthHeader = this._results.headers.filter((header: [string, string]) => {\r\n      return header[0] === 'content-length';\r\n    })[0];\r\n\r\n    if (contentLengthHeader) {\r\n      this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\r\n      this._onByte = this._collectBodyFixedSize;\r\n    } else {\r\n      this._onByte = this._collectBodyNullTerminated;\r\n    }\r\n  }\r\n\r\n  private _collectBodyNullTerminated(byte: number): void {\r\n    if (byte === NULL) {\r\n      this._retrievedBody();\r\n      return;\r\n    }\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _collectBodyFixedSize(byte: number): void {\r\n    // It is post decrement, so that we discard the trailing NULL octet\r\n    if (this._bodyBytesRemaining-- === 0) {\r\n      this._retrievedBody();\r\n      return;\r\n    }\r\n    this._consumeByte(byte);\r\n  }\r\n\r\n  private _retrievedBody() {\r\n    this._results.binaryBody = this._consumeTokenAsRaw();\r\n\r\n    this.onFrame(this._results);\r\n\r\n    this._initState();\r\n  }\r\n\r\n  // Rec Descent Parser helpers\r\n\r\n  private _consumeByte(byte: number) {\r\n    this._token.push(byte);\r\n  }\r\n\r\n  private _consumeTokenAsUTF8() {\r\n    return this._decoder.decode(this._consumeTokenAsRaw());\r\n  }\r\n\r\n  private _consumeTokenAsRaw() {\r\n    const rawResult = new Uint8Array(this._token);\r\n    this._token = [];\r\n    return rawResult;\r\n  }\r\n\r\n  private _initState() {\r\n    this._results = {\r\n      command: undefined,\r\n      headers: [],\r\n      binaryBody: undefined\r\n    };\r\n\r\n    this._token = [];\r\n    this._headerKey = undefined;\r\n\r\n    this._onByte = this._collectFrame;\r\n  }\r\n\r\n}\r\n","import {Client} from '../client';\r\nimport {StompHeaders} from '../stomp-headers';\r\nimport {frameCallbackType, messageCallbackType} from '../types';\r\nimport {HeartbeatInfo} from './heartbeat-info';\r\n\r\n/**\r\n * Available for backward compatibility, please shift to using {@link Client}.\r\n *\r\n * **Deprecated**\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\r\n */\r\nexport class CompatClient extends Client {\r\n\r\n  /**\r\n   * It is no op now. No longer needed. Large packets work out of the box.\r\n   */\r\n  public maxWebSocketFrameSize: number = 16 * 1024;\r\n\r\n  /**\r\n   * Available for backward compatibility, please shift to using {@link Client}\r\n   * and [Client#webSocketFactory]{@link Client#webSocketFactory}.\r\n   *\r\n   * **Deprecated**\r\n   *\r\n   * @internal\r\n   */\r\n  constructor(webSocketFactory: () => any) {\r\n    super();\r\n    this.reconnect_delay = 0;\r\n    this.webSocketFactory = webSocketFactory;\r\n    // Default from previous version\r\n    this.debug = (...message: any[]) => {\r\n      console.log(...message);\r\n    };\r\n  }\r\n\r\n  private _parseConnect(...args: any[]): any {\r\n    let closeEventCallback;\r\n    let connectCallback;\r\n    let errorCallback;\r\n    let headers: StompHeaders = {};\r\n    if (args.length < 2) {\r\n      throw new Error(('Connect requires at least 2 arguments'));\r\n    }\r\n    if (typeof(args[1]) === 'function') {\r\n      [headers, connectCallback, errorCallback, closeEventCallback] = args;\r\n    } else {\r\n      switch (args.length) {\r\n        case 6:\r\n          [headers.login, headers.passcode, connectCallback, errorCallback, closeEventCallback, headers.host] = args;\r\n          break;\r\n        default:\r\n          [headers.login, headers.passcode, connectCallback, errorCallback, closeEventCallback] = args;\r\n      }\r\n    }\r\n\r\n    return [headers, connectCallback, errorCallback, closeEventCallback];\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, please shift to using [Client#activate]{@link Client#activate}.\r\n   *\r\n   * **Deprecated**\r\n   *\r\n   * The `connect` method accepts different number of arguments and types. See the Overloads list. Use the\r\n   * version with headers to pass your broker specific options.\r\n   *\r\n   * overloads:\r\n   * - connect(headers, connectCallback)\r\n   * - connect(headers, connectCallback, errorCallback)\r\n   * - connect(login, passcode, connectCallback)\r\n   * - connect(login, passcode, connectCallback, errorCallback)\r\n   * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback)\r\n   * - connect(login, passcode, connectCallback, errorCallback, closeEventCallback, host)\r\n   *\r\n   * params:\r\n   * - headers, see [Client#connectHeaders]{@link Client#connectHeaders}\r\n   * - connectCallback, see [Client#onConnect]{@link Client#onConnect}\r\n   * - errorCallback, see [Client#onStompError]{@link Client#onStompError}\r\n   * - closeEventCallback, see [Client#onWebSocketClose]{@link Client#onWebSocketClose}\r\n   * - login [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\r\n   * - passcode [String], [Client#connectHeaders](../classes/Client.html#connectHeaders)\r\n   * - host [String], see [Client#connectHeaders](../classes/Client.html#connectHeaders)\r\n   *\r\n   * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\r\n   */\r\n  public connect(...args: any[]): void {\r\n    const out = this._parseConnect(...args);\r\n\r\n    if (out[0]) { this.connectHeaders = out[0]; }\r\n    if (out[1]) { this.onConnect = out[1]; }\r\n    if (out[2]) { this.onStompError = out[2]; }\r\n    if (out[3]) { this.onWebSocketClose = out[3]; }\r\n\r\n    super.activate();\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, please shift to using [Client#deactivate]{@link Client#deactivate}.\r\n   *\r\n   * **Deprecated**\r\n   *\r\n   * See:\r\n   * [Client#onDisconnect]{@link Client#onDisconnect}, and\r\n   * [Client#disconnectHeaders]{@link Client#disconnectHeaders}\r\n   *\r\n   * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\r\n   */\r\n  public disconnect(disconnectCallback?: any, headers: StompHeaders = {}): void {\r\n    if (disconnectCallback) {\r\n      this.onDisconnect = disconnectCallback;\r\n    }\r\n    this.disconnectHeaders = headers;\r\n\r\n    super.deactivate();\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, use [Client#publish]{@link Client#publish}.\r\n   *\r\n   * Send a message to a named destination. Refer to your STOMP broker documentation for types\r\n   * and naming of destinations. The headers will, typically, be available to the subscriber.\r\n   * However, there may be special purpose headers corresponding to your STOMP broker.\r\n   *\r\n   *  **Deprecated**, use [Client#publish]{@link Client#publish}\r\n   *\r\n   * Note: Body must be String. You will need to covert the payload to string in case it is not string (e.g. JSON)\r\n   *\r\n   * ```javascript\r\n   *        client.send(\"/queue/test\", {priority: 9}, \"Hello, STOMP\");\r\n   *\r\n   *        // If you want to send a message with a body, you must also pass the headers argument.\r\n   *        client.send(\"/queue/test\", {}, \"Hello, STOMP\");\r\n   * ```\r\n   *\r\n   * To upgrade, please follow the [Upgrade Guide](../additional-documentation/upgrading.html)\r\n   */\r\n  public send(destination: string, headers: {[key: string]: any} = {}, body: string = ''): void {\r\n    headers = (Object as any).assign({}, headers);\r\n\r\n    const skipContentLengthHeader = (headers['content-length'] === false);\r\n    if (skipContentLengthHeader) {\r\n      delete headers['content-length'];\r\n    }\r\n    this.publish({\r\n      destination,\r\n      headers: headers as StompHeaders,\r\n      body,\r\n      skipContentLengthHeader\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, renamed to [Client#reconnectDelay]{@link Client#reconnectDelay}.\r\n   *\r\n   * **Deprecated**\r\n   */\r\n  set reconnect_delay(value: number) {\r\n    this.reconnectDelay = value;\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, renamed to [Client#webSocket]{@link Client#webSocket}.\r\n   *\r\n   * **Deprecated**\r\n   */\r\n  get ws(): any {\r\n    return this._webSocket;\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, renamed to [Client#connectedVersion]{@link Client#connectedVersion}.\r\n   *\r\n   * **Deprecated**\r\n   */\r\n  get version() {\r\n    return this.connectedVersion;\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\r\n   *\r\n   * **Deprecated**\r\n   */\r\n  get onreceive(): messageCallbackType {\r\n    return this.onUnhandledMessage;\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, renamed to [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\r\n   *\r\n   * **Deprecated**\r\n   */\r\n  set onreceive(value: messageCallbackType) {\r\n    this.onUnhandledMessage = value;\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\r\n   * Prefer using [Client#watchForReceipt]{@link Client#watchForReceipt}.\r\n   *\r\n   * **Deprecated**\r\n   */\r\n  get onreceipt(): frameCallbackType {\r\n    return this.onUnhandledReceipt;\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, renamed to [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\r\n   *\r\n   * **Deprecated**\r\n   */\r\n  set onreceipt(value: frameCallbackType) {\r\n    this.onUnhandledReceipt = value;\r\n  }\r\n\r\n  private _heartbeatInfo: HeartbeatInfo = new HeartbeatInfo(this);\r\n\r\n  /**\r\n   * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\r\n   * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\r\n   *\r\n   * **Deprecated**\r\n   */\r\n  get heartbeat() {\r\n    return this._heartbeatInfo;\r\n  }\r\n\r\n  /**\r\n   * Available for backward compatibility, renamed to [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}\r\n   * [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\r\n   *\r\n   * **Deprecated**\r\n   */\r\n  set heartbeat(value: {incoming: number, outgoing: number}) {\r\n    this.heartbeatIncoming = value.incoming;\r\n    this.heartbeatOutgoing = value.outgoing;\r\n  }\r\n}\r\n","export * from './client';\r\nexport * from './frame-impl';\r\nexport * from './i-frame';\r\nexport * from './i-message';\r\nexport * from './parser';\r\nexport * from './stomp-config';\r\nexport * from './stomp-headers';\r\nexport * from './stomp-subscription';\r\nexport * from './i-transaction';\r\nexport * from './types';\r\nexport * from './versions';\r\nexport * from './web-socket-state';\r\n\r\n// Compatibility code\r\nexport * from './compatibility/compat-client';\r\nexport * from './compatibility/stomp';\r\n","import {BYTE} from './byte';\r\nimport {Client} from './client';\r\nimport {FrameImpl} from './frame-impl';\r\nimport {IMessage} from './i-message';\r\nimport {ITransaction} from './i-transaction';\r\nimport {Parser} from './parser';\r\nimport {StompConfig} from './stomp-config';\r\nimport {StompHeaders} from './stomp-headers';\r\nimport {StompSubscription} from './stomp-subscription';\r\nimport {\r\n  closeEventCallbackType,\r\n  debugFnType,\r\n  frameCallbackType,\r\n  IPublishParams,\r\n  messageCallbackType,\r\n  wsErrorCallbackType\r\n} from './types';\r\nimport {Versions} from './versions';\r\nimport {WebSocketState} from './web-socket-state';\r\n\r\n/**\r\n * The STOMP protocol handler\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * @internal\r\n */\r\nexport class StompHandler {\r\n  public debug: debugFnType;\r\n\r\n  public stompVersions: Versions;\r\n\r\n  public connectHeaders: StompHeaders;\r\n\r\n  public disconnectHeaders: StompHeaders;\r\n\r\n  public heartbeatIncoming: number;\r\n\r\n  public heartbeatOutgoing: number;\r\n\r\n  public onUnhandledMessage: messageCallbackType;\r\n\r\n  public onUnhandledReceipt: frameCallbackType;\r\n\r\n  public onUnhandledFrame: frameCallbackType;\r\n\r\n  public onConnect: frameCallbackType;\r\n\r\n  public onDisconnect: frameCallbackType;\r\n\r\n  public onStompError: frameCallbackType;\r\n\r\n  public onWebSocketClose: closeEventCallbackType;\r\n\r\n  public onWebSocketError: wsErrorCallbackType;\r\n\r\n  public logRawCommunication: boolean;\r\n\r\n  public splitLargeFrames: boolean;\r\n\r\n  public maxWebSocketChunkSize: number;\r\n\r\n  public forceBinaryWSFrames: boolean;\r\n\r\n  public appendMissingNULLonIncoming: boolean;\r\n\r\n  public useLegacyHeartbeatLogic: boolean;\r\n\r\n  get connectedVersion(): string {\r\n    return this._connectedVersion;\r\n  }\r\n  private _connectedVersion: string;\r\n\r\n  get connected(): boolean {\r\n    return this._connected;\r\n  }\r\n\r\n  private _connected: boolean;\r\n\r\n  private readonly _subscriptions: { [key: string]: messageCallbackType };\r\n  private readonly _receiptWatchers: { [key: string]: frameCallbackType };\r\n  private _partialData: string;\r\n  private _escapeHeaderValues: boolean;\r\n  private _counter: number;\r\n  private _pinger: any;\r\n  private _ponger: any;\r\n  private _lastServerActivityTS: number;\r\n  private _ttlI: number;\r\n  private _ttlO: number;\r\n  private _lastTimeSetHeartbeatInterval: number;\r\n\r\n  constructor(private _client: Client, private _webSocket: WebSocket, config: StompConfig = {}) {\r\n    // used to index subscribers\r\n    this._counter = 0;\r\n\r\n    // subscription callbacks indexed by subscriber's ID\r\n    this._subscriptions = {};\r\n\r\n    // receipt-watchers indexed by receipts-ids\r\n    this._receiptWatchers = {};\r\n\r\n    this._partialData = '';\r\n\r\n    this._escapeHeaderValues = false;\r\n\r\n    this._lastServerActivityTS = Date.now();\r\n\r\n    this.configure(config);\r\n  }\r\n\r\n  public configure(conf: StompConfig): void {\r\n    // bulk assign all properties to this\r\n    (Object as any).assign(this, conf);\r\n  }\r\n\r\n  public start(): void {\r\n    const parser = new Parser(\r\n      // On Frame\r\n      (rawFrame) => {\r\n        const frame = FrameImpl.fromRawFrame(rawFrame, this._escapeHeaderValues);\r\n\r\n        // if this.logRawCommunication is set, the rawChunk is logged at this._webSocket.onmessage\r\n        if (!this.logRawCommunication) {\r\n          this.debug(`<<< ${frame}`);\r\n        }\r\n\r\n        const serverFrameHandler = this._serverFrameHandlers[frame.command] || this.onUnhandledFrame;\r\n        serverFrameHandler(frame);\r\n      },\r\n      // On Incoming Ping\r\n      () => {\r\n        this.debug('<<< PONG');\r\n        console.log('this.useLegacyHeartbeatLogic: ' + this.useLegacyHeartbeatLogic );\r\n        if (this.useLegacyHeartbeatLogic || !this._ttlO || !this._ttlI) {\r\n          return;\r\n        }\r\n        const oldPinger = this._pinger;\r\n        const oldPonger = this._ponger;\r\n        if (Date.now() - this._lastTimeSetHeartbeatInterval < Math.max(this._ttlI, this._ttlO) - 1000) {\r\n          return;\r\n        }\r\n        this._lastTimeSetHeartbeatInterval = Date.now();\r\n        setTimeout(() => {\r\n          clearInterval(oldPinger);\r\n          clearInterval(oldPonger);\r\n        }, 2000); // BLUEIQ NOTE: This is hardcoded since this solution is more of a hack.\r\n        this._pinger = setInterval(() => {\r\n          if (this._webSocket.readyState === WebSocketState.OPEN) {\r\n            this._webSocket.send(BYTE.LF);\r\n            this.debug('>>> PING');\r\n          }\r\n        }, this._ttlI);\r\n        this._ponger = setInterval(() => {\r\n          const delta = Date.now() - this._lastServerActivityTS;\r\n          // We wait twice the TTL to be flexible on window's setInterval calls\r\n          if (delta > (this._ttlO * 2)) {\r\n            this.debug(`did not receive server activity for the last ${delta}ms`);\r\n            this._webSocket.close();\r\n          }\r\n        }, this._ttlO);\r\n      }\r\n    );\r\n\r\n    this._webSocket.onmessage = (evt: any) => {\r\n      this.debug('Received data');\r\n      this._lastServerActivityTS = Date.now();\r\n\r\n      if (this.logRawCommunication) {\r\n        const rawChunkAsString = (evt.data instanceof ArrayBuffer) ? new TextDecoder().decode(evt.data) : evt.data;\r\n        this.debug(`<<< ${rawChunkAsString}`);\r\n      }\r\n\r\n      parser.parseChunk(evt.data, this.appendMissingNULLonIncoming);\r\n    };\r\n\r\n    this._webSocket.onclose = (closeEvent: CloseEvent): void => {\r\n      this.debug(`Connection closed to ${this._webSocket.url}`);\r\n      this.onWebSocketClose(closeEvent);\r\n      this._cleanUp();\r\n    };\r\n\r\n    this._webSocket.onerror = (errorEvent: Event): void => {\r\n      this.onWebSocketError(errorEvent);\r\n    };\r\n\r\n    this._webSocket.onopen = () => {\r\n      // Clone before updating\r\n      const connectHeaders = (Object as any).assign({}, this.connectHeaders);\r\n\r\n      this.debug('Web Socket Opened...');\r\n      connectHeaders['accept-version'] = this.stompVersions.supportedVersions();\r\n      connectHeaders['heart-beat'] = [this.heartbeatOutgoing, this.heartbeatIncoming].join(',');\r\n      this._transmit({command: 'CONNECT', headers: connectHeaders});\r\n    };\r\n  }\r\n\r\n  private readonly _serverFrameHandlers: { [key: string]: frameCallbackType } = {\r\n\r\n    // [CONNECTED Frame](http://stomp.github.com/stomp-specification-1.2.html#CONNECTED_Frame)\r\n    CONNECTED: (frame) => {\r\n      this.debug(`connected to server ${frame.headers.server}`);\r\n      this._connected = true;\r\n      this._connectedVersion = frame.headers.version;\r\n      // STOMP version 1.2 needs header values to be escaped\r\n      if (this._connectedVersion === Versions.V1_2) {\r\n        this._escapeHeaderValues = true;\r\n      }\r\n\r\n      this._setupHeartbeat(frame.headers);\r\n      this.onConnect(frame);\r\n    },\r\n\r\n    // [MESSAGE Frame](http://stomp.github.com/stomp-specification-1.2.html#MESSAGE)\r\n    MESSAGE: (frame) => {\r\n      // the callback is registered when the client calls\r\n      // `subscribe()`.\r\n      // If there is no registered subscription for the received message,\r\n      // the default `onUnhandledMessage` callback is used that the client can set.\r\n      // This is useful for subscriptions that are automatically created\r\n      // on the browser side (e.g. [RabbitMQ's temporary\r\n      // queues](http://www.rabbitmq.com/stomp.html)).\r\n      const subscription = frame.headers.subscription;\r\n      const onReceive = this._subscriptions[subscription] || this.onUnhandledMessage;\r\n\r\n      // bless the frame to be a Message\r\n      const message = frame as IMessage;\r\n\r\n      const client = this;\r\n      const messageId = this._connectedVersion === Versions.V1_2 ? message.headers.ack : message.headers['message-id'];\r\n\r\n      // add `ack()` and `nack()` methods directly to the returned frame\r\n      // so that a simple call to `message.ack()` can acknowledge the message.\r\n      message.ack = (headers: StompHeaders = {}): void => {\r\n        return client.ack(messageId, subscription, headers);\r\n      };\r\n      message.nack = (headers: StompHeaders = {}): void => {\r\n        return client.nack(messageId, subscription, headers);\r\n      };\r\n      onReceive(message);\r\n    },\r\n\r\n    // [RECEIPT Frame](http://stomp.github.com/stomp-specification-1.2.html#RECEIPT)\r\n    RECEIPT: (frame) => {\r\n      const callback = this._receiptWatchers[frame.headers['receipt-id']];\r\n      if (callback) {\r\n        callback(frame);\r\n        // Server will acknowledge only once, remove the callback\r\n        delete this._receiptWatchers[frame.headers['receipt-id']];\r\n      } else {\r\n        this.onUnhandledReceipt(frame);\r\n      }\r\n    },\r\n\r\n    // [ERROR Frame](http://stomp.github.com/stomp-specification-1.2.html#ERROR)\r\n    ERROR: (frame) => {\r\n      this.onStompError(frame);\r\n    }\r\n  };\r\n\r\n  private _setupHeartbeat(headers: StompHeaders): void {\r\n    if ((headers.version !== Versions.V1_1 && headers.version !== Versions.V1_2)) {\r\n      return;\r\n    }\r\n\r\n    // heart-beat header received from the server looks like:\r\n    //\r\n    //     heart-beat: sx, sy\r\n    const [serverOutgoing, serverIncoming] = (headers['heart-beat']).split(',').map((v: string) => parseInt(v, 10));\r\n\r\n    if ((this.heartbeatOutgoing !== 0) && (serverIncoming !== 0)) {\r\n      this._ttlI = Math.max(this.heartbeatOutgoing, serverIncoming);\r\n      this.debug(`send PING every ${this._ttlI}ms`);\r\n      this._pinger = setInterval(() => {\r\n        if (this._webSocket.readyState === WebSocketState.OPEN) {\r\n          this._webSocket.send(BYTE.LF);\r\n          this.debug('>>> PING');\r\n        }\r\n      }, this._ttlI);\r\n    }\r\n\r\n    if ((this.heartbeatIncoming !== 0) && (serverOutgoing !== 0)) {\r\n      this._ttlO = Math.max(this.heartbeatIncoming, serverOutgoing);\r\n      this.debug(`check PONG every ${this._ttlO}ms`);\r\n      this._ponger = setInterval(() => {\r\n        const delta = Date.now() - this._lastServerActivityTS;\r\n        // We wait twice the TTL to be flexible on window's setInterval calls\r\n        if (delta > (this._ttlO * 2)) {\r\n          this.debug(`did not receive server activity for the last ${delta}ms`);\r\n          this._webSocket.close();\r\n        }\r\n      }, this._ttlO);\r\n    }\r\n  }\r\n\r\n  private _transmit(params: { command: string, headers?: StompHeaders,\r\n                              body?: string, binaryBody?: Uint8Array, skipContentLengthHeader?: boolean }): void {\r\n    const {command, headers, body, binaryBody, skipContentLengthHeader} = params;\r\n    const frame = new FrameImpl({\r\n      command,\r\n      headers,\r\n      body,\r\n      binaryBody,\r\n      escapeHeaderValues: this._escapeHeaderValues,\r\n      skipContentLengthHeader\r\n    });\r\n\r\n    let rawChunk = frame.serialize();\r\n\r\n    if (this.logRawCommunication) {\r\n      this.debug(`>>> ${rawChunk}`);\r\n    } else {\r\n      this.debug(`>>> ${frame}`);\r\n    }\r\n\r\n    if (this.forceBinaryWSFrames && typeof rawChunk === 'string') {\r\n      rawChunk = new TextEncoder().encode(rawChunk);\r\n    }\r\n\r\n    if (typeof rawChunk !== 'string' || !this.splitLargeFrames) {\r\n      this._webSocket.send(rawChunk);\r\n    } else {\r\n      let out = rawChunk as string;\r\n      while (out.length > 0) {\r\n        const chunk = out.substring(0, this.maxWebSocketChunkSize);\r\n        out = out.substring(this.maxWebSocketChunkSize);\r\n        this._webSocket.send(chunk);\r\n        this.debug(`chunk sent = ${chunk.length}, remaining = ${out.length}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  public dispose(): void {\r\n    if (this.connected) {\r\n      try {\r\n        // clone before updating\r\n        const disconnectHeaders = (Object as any).assign({}, this.disconnectHeaders);\r\n\r\n        if (!disconnectHeaders.receipt) {\r\n          disconnectHeaders.receipt = `close-${this._counter++}`;\r\n        }\r\n        this.watchForReceipt(disconnectHeaders.receipt, (frame) => {\r\n          this._webSocket.close();\r\n          this._cleanUp();\r\n          this.onDisconnect(frame);\r\n        });\r\n        this._transmit({command: 'DISCONNECT', headers: disconnectHeaders});\r\n      } catch (error) {\r\n        this.debug(`Ignoring error during disconnect ${error}`);\r\n      }\r\n    } else {\r\n      if (this._webSocket.readyState === WebSocketState.CONNECTING\r\n            || this._webSocket.readyState === WebSocketState.OPEN) {\r\n        this._webSocket.close();\r\n      }\r\n    }\r\n  }\r\n\r\n  private _cleanUp() {\r\n    this._connected = false;\r\n\r\n    if (this._pinger) {\r\n      clearInterval(this._pinger);\r\n    }\r\n    if (this._ponger) {\r\n      clearInterval(this._ponger);\r\n    }\r\n  }\r\n\r\n  public publish(params: IPublishParams): void {\r\n    const {destination, headers, body, binaryBody, skipContentLengthHeader} = params;\r\n    const hdrs: StompHeaders = (Object as any).assign({destination}, headers);\r\n    this._transmit({\r\n      command: 'SEND',\r\n      headers: hdrs,\r\n      body,\r\n      binaryBody,\r\n      skipContentLengthHeader\r\n    });\r\n  }\r\n\r\n  public watchForReceipt(receiptId: string, callback: frameCallbackType): void {\r\n    this._receiptWatchers[receiptId] = callback;\r\n  }\r\n\r\n  public subscribe(destination: string, callback: messageCallbackType, headers: StompHeaders = {}): StompSubscription {\r\n    headers = (Object as any).assign({}, headers);\r\n\r\n    if (!headers.id) {\r\n      headers.id = `sub-${this._counter++}`;\r\n    }\r\n    headers.destination = destination;\r\n    this._subscriptions[headers.id] = callback;\r\n    this._transmit({command: 'SUBSCRIBE', headers});\r\n    const client = this;\r\n    return {\r\n      id: headers.id,\r\n\r\n      unsubscribe(hdrs) {\r\n        return client.unsubscribe(headers.id, hdrs);\r\n      }\r\n    };\r\n  }\r\n\r\n  public unsubscribe(id: string, headers: StompHeaders = {}): void {\r\n    headers = (Object as any).assign({}, headers);\r\n\r\n    delete this._subscriptions[id];\r\n    headers.id = id;\r\n    this._transmit({command: 'UNSUBSCRIBE', headers});\r\n  }\r\n\r\n  public begin(transactionId: string): ITransaction {\r\n    const txId = transactionId || (`tx-${this._counter++}`);\r\n    this._transmit({\r\n      command: 'BEGIN', headers: {\r\n        transaction: txId\r\n      }\r\n    });\r\n    const client = this;\r\n    return {\r\n      id: txId,\r\n      commit(): void {\r\n        client.commit(txId);\r\n      },\r\n      abort(): void {\r\n        client.abort(txId);\r\n      }\r\n    };\r\n  }\r\n\r\n  public commit(transactionId: string): void {\r\n    this._transmit({\r\n      command: 'COMMIT', headers: {\r\n        transaction: transactionId\r\n      }\r\n    });\r\n  }\r\n\r\n  public abort(transactionId: string): void {\r\n    this._transmit({\r\n      command: 'ABORT', headers: {\r\n        transaction: transactionId\r\n      }\r\n    });\r\n  }\r\n\r\n  public ack(messageId: string, subscriptionId: string, headers: StompHeaders = {}): void {\r\n    headers = (Object as any).assign({}, headers);\r\n\r\n    if (this._connectedVersion === Versions.V1_2) {\r\n      headers.id = messageId;\r\n    } else {\r\n      headers['message-id'] = messageId;\r\n    }\r\n    headers.subscription = subscriptionId;\r\n    this._transmit({command: 'ACK', headers});\r\n  }\r\n\r\n  public nack(messageId: string, subscriptionId: string, headers: StompHeaders = {}): void {\r\n    headers = (Object as any).assign({}, headers);\r\n\r\n    if (this._connectedVersion === Versions.V1_2) {\r\n      headers.id = messageId;\r\n    } else {\r\n      headers['message-id'] = messageId;\r\n    }\r\n    headers.subscription = subscriptionId;\r\n    return this._transmit({command: 'NACK', headers});\r\n  }\r\n\r\n}\r\n","import {StompHeaders} from './stomp-headers';\r\nimport {\r\n  closeEventCallbackType,\r\n  debugFnType,\r\n  frameCallbackType,\r\n  messageCallbackType,\r\n  wsErrorCallbackType\r\n} from './types';\r\nimport {Versions} from './versions';\r\n\r\n/**\r\n * Configuration options for STOMP Client, each key corresponds to\r\n * field by the same name in {@link Client}. This can be passed to\r\n * the constructor of {@link Client} or to [Client#configure]{@link Client#configure}.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n */\r\nexport class StompConfig {\r\n  /**\r\n   * See [Client#brokerURL]{@link Client#brokerURL}.\r\n   */\r\n  public brokerURL?: string;\r\n\r\n  /**\r\n   * See See [Client#stompVersions]{@link Client#stompVersions}.\r\n   */\r\n  public stompVersions?: Versions;\r\n\r\n  /**\r\n   * See [Client#webSocketFactory]{@link Client#webSocketFactory}.\r\n   */\r\n  public webSocketFactory?: () => any;\r\n\r\n  /**\r\n   * See [Client#reconnectDelay]{@link Client#reconnectDelay}.\r\n   */\r\n  public reconnectDelay?: number;\r\n\r\n  /**\r\n   * See [Client#heartbeatIncoming]{@link Client#heartbeatIncoming}.\r\n   */\r\n  public heartbeatIncoming?: number;\r\n\r\n  /**\r\n   * See [Client#heartbeatOutgoing]{@link Client#heartbeatOutgoing}.\r\n   */\r\n  public heartbeatOutgoing?: number;\r\n\r\n  /**\r\n   * See [Client#useLegacyHeartbeatLogic]{@link Client#useLegacyHeartbeatLogic}.\r\n   */\r\n  public useLegacyHeartbeatLogic?: boolean;\r\n\r\n  /**\r\n   * See [Client#splitLargeFrames]{@link Client#splitLargeFrames}.\r\n   */\r\n  public splitLargeFrames?: boolean;\r\n\r\n  /**\r\n   * See [Client#forceBinaryWSFrames]{@link Client#forceBinaryWSFrames}.\r\n   */\r\n  public forceBinaryWSFrames?: boolean;\r\n\r\n  /**\r\n   * See [Client#appendMissingNULLonIncoming]{@link Client#appendMissingNULLonIncoming}.\r\n   */\r\n  public appendMissingNULLonIncoming?: boolean;\r\n\r\n  /**\r\n   * See [Client#maxWebSocketChunkSize]{@link Client#maxWebSocketChunkSize}.\r\n   */\r\n  public maxWebSocketChunkSize?: number;\r\n\r\n  /**\r\n   * See [Client#connectHeaders]{@link Client#connectHeaders}.\r\n   */\r\n  public connectHeaders?: StompHeaders;\r\n\r\n  /**\r\n   * See [Client#disconnectHeaders]{@link Client#disconnectHeaders}.\r\n   */\r\n  public disconnectHeaders?: StompHeaders;\r\n\r\n  /**\r\n   * See [Client#onUnhandledMessage]{@link Client#onUnhandledMessage}.\r\n   */\r\n  public onUnhandledMessage?: messageCallbackType;\r\n\r\n  /**\r\n   * See [Client#onUnhandledReceipt]{@link Client#onUnhandledReceipt}.\r\n   */\r\n  public onUnhandledReceipt?: frameCallbackType;\r\n\r\n  /**\r\n   * See [Client#onUnhandledFrame]{@link Client#onUnhandledFrame}.\r\n   */\r\n  public onUnhandledFrame?: frameCallbackType;\r\n\r\n  /**\r\n   * See [Client#beforeConnect]{@link Client#beforeConnect}.\r\n   */\r\n  public beforeConnect?: () => void|Promise<void>;\r\n\r\n  /**\r\n   * See [Client#onConnect]{@link Client#onConnect}.\r\n   */\r\n  public onConnect?: frameCallbackType;\r\n\r\n  /**\r\n   * See [Client#onDisconnect]{@link Client#onDisconnect}.\r\n   */\r\n  public onDisconnect?: frameCallbackType;\r\n\r\n  /**\r\n   * See [Client#onStompError]{@link Client#onStompError}.\r\n   */\r\n  public onStompError?: frameCallbackType;\r\n\r\n  /**\r\n   * See [Client#onWebSocketClose]{@link Client#onWebSocketClose}.\r\n   */\r\n  public onWebSocketClose?: closeEventCallbackType;\r\n\r\n  /**\r\n   * See [Client#onWebSocketError]{@link Client#onWebSocketError}.\r\n   */\r\n  public onWebSocketError?: wsErrorCallbackType;\r\n\r\n  /**\r\n   * See [Client#logRawCommunication]{@link Client#logRawCommunication}.\r\n   */\r\n  public logRawCommunication?: boolean;\r\n\r\n  /**\r\n   * See [Client#debug]{@link Client#debug}.\r\n   */\r\n  public debug?: debugFnType;\r\n}\r\n","/**\r\n * STOMP headers. Many functions calls will accept headers as parameters.\r\n * The headers sent by Broker will be available as [IFrame#headers]{@link IFrame#headers}.\r\n *\r\n * `key` and `value` must be valid strings.\r\n * In addition, `key` must not contain `CR`, `LF`, or `:`.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n */\r\nexport class StompHeaders { [key: string]: string }\r\n","import {StompHeaders} from './stomp-headers';\r\n\r\n/**\r\n * Call [Client#subscribe]{@link Client#subscribe} to create a StompSubscription.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n */\r\nexport class StompSubscription {\r\n  /**\r\n   * Id associated with this subscription.\r\n   */\r\n  public id: string;\r\n\r\n  /**\r\n   * Unsubscribe. See [Client#unsubscribe]{@link Client#unsubscribe} for an example.\r\n   */\r\n  public unsubscribe: (headers?: StompHeaders) => void;\r\n}\r\n","import {CompatClient} from './compat-client';\r\n\r\n/**\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * @internal\r\n */\r\nexport class HeartbeatInfo {\r\n  constructor(private client: CompatClient) {\r\n  }\r\n\r\n  get outgoing(): number {\r\n    return this.client.heartbeatOutgoing;\r\n  }\r\n\r\n  set outgoing(value: number) {\r\n    this.client.heartbeatOutgoing = value;\r\n  }\r\n\r\n  get incoming(): number {\r\n    return this.client.heartbeatIncoming;\r\n  }\r\n\r\n  set incoming(value: number) {\r\n    this.client.heartbeatIncoming = value;\r\n  }\r\n}\r\n","import {Versions} from '../versions';\r\nimport {CompatClient} from './compat-client';\r\n\r\n/**\r\n * STOMP Class, acts like a factory to create {@link Client}.\r\n *\r\n * Part of `@stomp/stompjs`.\r\n *\r\n * **Deprecated**\r\n *\r\n * It will be removed in next major version. Please switch to {@link Client}.\r\n */\r\nexport class Stomp {\r\n  /**\r\n   * In case you need to use a non standard class for WebSocket.\r\n   *\r\n   * For example when using within NodeJS environment:\r\n   *\r\n   * ```javascript\r\n   *        StompJs = require('../../esm5/');\r\n   *        Stomp = StompJs.Stomp;\r\n   *        Stomp.WebSocketClass = require('websocket').w3cwebsocket;\r\n   * ```\r\n   *\r\n   * **Deprecated**\r\n   *\r\n   *\r\n   * It will be removed in next major version. Please switch to {@link Client}\r\n   * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\r\n   */\r\n  // tslint:disable-next-line:variable-name\r\n  public static WebSocketClass: any = null;\r\n\r\n  /**\r\n   * This method creates a WebSocket client that is connected to\r\n   * the STOMP server located at the url.\r\n   *\r\n   * ```javascript\r\n   *        var url = \"ws://localhost:61614/stomp\";\r\n   *        var client = Stomp.client(url);\r\n   * ```\r\n   *\r\n   * **Deprecated**\r\n   *\r\n   * It will be removed in next major version. Please switch to {@link Client}\r\n   * using [Client#brokerURL]{@link Client#brokerURL}.\r\n   */\r\n  public static client(url: string, protocols?: string[]): CompatClient {\r\n    // This is a hack to allow another implementation than the standard\r\n    // HTML5 WebSocket class.\r\n    //\r\n    // It is possible to use another class by calling\r\n    //\r\n    //     Stomp.WebSocketClass = MozWebSocket\r\n    //\r\n    // *prior* to call `Stomp.client()`.\r\n    //\r\n    // This hack is deprecated and `Stomp.over()` method should be used\r\n    // instead.\r\n\r\n    // See remarks on the function Stomp.over\r\n    if (protocols == null) { protocols = Versions.default.protocolVersions(); }\r\n    const wsFn = () => {\r\n      const klass = Stomp.WebSocketClass || WebSocket;\r\n      return new klass(url, protocols);\r\n    };\r\n\r\n    return new CompatClient(wsFn);\r\n  }\r\n\r\n  /**\r\n   * This method is an alternative to [Stomp#client]{@link Stomp#client} to let the user\r\n   * specify the WebSocket to use (either a standard HTML5 WebSocket or\r\n   * a similar object).\r\n   *\r\n   * In order to support reconnection, the function Client._connect should be callable more than once.\r\n   * While reconnecting\r\n   * a new instance of underlying transport (TCP Socket, WebSocket or SockJS) will be needed. So, this function\r\n   * alternatively allows passing a function that should return a new instance of the underlying socket.\r\n   *\r\n   * ```javascript\r\n   *        var client = Stomp.over(function(){\r\n   *          return new WebSocket('ws://localhost:15674/ws')\r\n   *        });\r\n   * ```\r\n   *\r\n   * **Deprecated**\r\n   *\r\n   * It will be removed in next major version. Please switch to {@link Client}\r\n   * using [Client#webSocketFactory]{@link Client#webSocketFactory}.\r\n   */\r\n  public static over(ws: any): CompatClient {\r\n    let wsFn: () => any;\r\n\r\n    if (typeof (ws) === 'function') {\r\n      wsFn = ws;\r\n    } else {\r\n      console.warn('Stomp.over did not receive a factory, auto reconnect will not work. ' +\r\n        'Please see https://stomp-js.github.io/api-docs/latest/classes/Stomp.html#over');\r\n      wsFn = () => ws;\r\n    }\r\n\r\n    return new CompatClient(wsFn);\r\n  }\r\n}\r\n"],"sourceRoot":""}